// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpc/apis.proto

package rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import empty "github.com/golang/protobuf/ptypes/empty"
import pb1 "github.com/iost-official/go-iost/core/block/pb"
import contract "github.com/iost-official/go-iost/core/contract"
import event "github.com/iost-official/go-iost/core/event"
import pb "github.com/iost-official/go-iost/core/tx/pb"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HashReq struct {
	// transaction hash
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HashReq) Reset()         { *m = HashReq{} }
func (m *HashReq) String() string { return proto.CompactTextString(m) }
func (*HashReq) ProtoMessage()    {}
func (*HashReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{0}
}
func (m *HashReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HashReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashReq.Merge(dst, src)
}
func (m *HashReq) XXX_Size() int {
	return m.Size()
}
func (m *HashReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HashReq.DiscardUnknown(m)
}

var xxx_messageInfo_HashReq proto.InternalMessageInfo

func (m *HashReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type BlockByHashReq struct {
	// block hash
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// complete means return the whole block or just blockhead+txhash_list
	Complete             bool     `protobuf:"varint,2,opt,name=complete,proto3" json:"complete,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockByHashReq) Reset()         { *m = BlockByHashReq{} }
func (m *BlockByHashReq) String() string { return proto.CompactTextString(m) }
func (*BlockByHashReq) ProtoMessage()    {}
func (*BlockByHashReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{1}
}
func (m *BlockByHashReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockByHashReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockByHashReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockByHashReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockByHashReq.Merge(dst, src)
}
func (m *BlockByHashReq) XXX_Size() int {
	return m.Size()
}
func (m *BlockByHashReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockByHashReq.DiscardUnknown(m)
}

var xxx_messageInfo_BlockByHashReq proto.InternalMessageInfo

func (m *BlockByHashReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *BlockByHashReq) GetComplete() bool {
	if m != nil {
		return m.Complete
	}
	return false
}

type BlockByNumReq struct {
	// block number
	Num int64 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	// complete means return the whole block or just blockhead+txhash_list
	Complete             bool     `protobuf:"varint,2,opt,name=complete,proto3" json:"complete,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockByNumReq) Reset()         { *m = BlockByNumReq{} }
func (m *BlockByNumReq) String() string { return proto.CompactTextString(m) }
func (*BlockByNumReq) ProtoMessage()    {}
func (*BlockByNumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{2}
}
func (m *BlockByNumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockByNumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockByNumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockByNumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockByNumReq.Merge(dst, src)
}
func (m *BlockByNumReq) XXX_Size() int {
	return m.Size()
}
func (m *BlockByNumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockByNumReq.DiscardUnknown(m)
}

var xxx_messageInfo_BlockByNumReq proto.InternalMessageInfo

func (m *BlockByNumReq) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *BlockByNumReq) GetComplete() bool {
	if m != nil {
		return m.Complete
	}
	return false
}

type GetAccountReq struct {
	// account ID
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// useLongestChain means whether getting the balance also from pending blocks(in the longest chain)
	UseLongestChain      bool     `protobuf:"varint,2,opt,name=useLongestChain,proto3" json:"useLongestChain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAccountReq) Reset()         { *m = GetAccountReq{} }
func (m *GetAccountReq) String() string { return proto.CompactTextString(m) }
func (*GetAccountReq) ProtoMessage()    {}
func (*GetAccountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{3}
}
func (m *GetAccountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAccountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountReq.Merge(dst, src)
}
func (m *GetAccountReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountReq proto.InternalMessageInfo

func (m *GetAccountReq) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *GetAccountReq) GetUseLongestChain() bool {
	if m != nil {
		return m.UseLongestChain
	}
	return false
}

type GetContractStorageReq struct {
	ContractID string `protobuf:"bytes,1,opt,name=contractID,proto3" json:"contractID,omitempty"`
	// the key in the StateDB
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// get the value from StateDB,field is needed if StateDB[key] is a map.(we get StateDB[key][field] in this case)
	Field                string   `protobuf:"bytes,3,opt,name=field,proto3" json:"field,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContractStorageReq) Reset()         { *m = GetContractStorageReq{} }
func (m *GetContractStorageReq) String() string { return proto.CompactTextString(m) }
func (*GetContractStorageReq) ProtoMessage()    {}
func (*GetContractStorageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{4}
}
func (m *GetContractStorageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContractStorageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContractStorageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetContractStorageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContractStorageReq.Merge(dst, src)
}
func (m *GetContractStorageReq) XXX_Size() int {
	return m.Size()
}
func (m *GetContractStorageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContractStorageReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetContractStorageReq proto.InternalMessageInfo

func (m *GetContractStorageReq) GetContractID() string {
	if m != nil {
		return m.ContractID
	}
	return ""
}

func (m *GetContractStorageReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *GetContractStorageReq) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

type GetContractReq struct {
	// contract id
	ContractID           string   `protobuf:"bytes,1,opt,name=contractID,proto3" json:"contractID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContractReq) Reset()         { *m = GetContractReq{} }
func (m *GetContractReq) String() string { return proto.CompactTextString(m) }
func (*GetContractReq) ProtoMessage()    {}
func (*GetContractReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{5}
}
func (m *GetContractReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContractReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContractReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetContractReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContractReq.Merge(dst, src)
}
func (m *GetContractReq) XXX_Size() int {
	return m.Size()
}
func (m *GetContractReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContractReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetContractReq proto.InternalMessageInfo

func (m *GetContractReq) GetContractID() string {
	if m != nil {
		return m.ContractID
	}
	return ""
}

type TxReq struct {
	Tx                   *pb.Tx   `protobuf:"bytes,1,opt,name=tx" json:"tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxReq) Reset()         { *m = TxReq{} }
func (m *TxReq) String() string { return proto.CompactTextString(m) }
func (*TxReq) ProtoMessage()    {}
func (*TxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{6}
}
func (m *TxReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxReq.Merge(dst, src)
}
func (m *TxReq) XXX_Size() int {
	return m.Size()
}
func (m *TxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TxReq.DiscardUnknown(m)
}

var xxx_messageInfo_TxReq proto.InternalMessageInfo

func (m *TxReq) GetTx() *pb.Tx {
	if m != nil {
		return m.Tx
	}
	return nil
}

type SubscribeReq struct {
	// type of event:0-TransactionResult,1-ContractEvent,2-ContractUserEvent,3-ContractSystemEvent
	Topics               []event.Event_Topic `protobuf:"varint,1,rep,packed,name=topics,enum=event.Event_Topic" json:"topics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SubscribeReq) Reset()         { *m = SubscribeReq{} }
func (m *SubscribeReq) String() string { return proto.CompactTextString(m) }
func (*SubscribeReq) ProtoMessage()    {}
func (*SubscribeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{7}
}
func (m *SubscribeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SubscribeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeReq.Merge(dst, src)
}
func (m *SubscribeReq) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeReq.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeReq proto.InternalMessageInfo

func (m *SubscribeReq) GetTopics() []event.Event_Topic {
	if m != nil {
		return m.Topics
	}
	return nil
}

type PeerInfo struct {
	ID                   string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Addr                 string   `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerInfo) Reset()         { *m = PeerInfo{} }
func (m *PeerInfo) String() string { return proto.CompactTextString(m) }
func (*PeerInfo) ProtoMessage()    {}
func (*PeerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{8}
}
func (m *PeerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PeerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerInfo.Merge(dst, src)
}
func (m *PeerInfo) XXX_Size() int {
	return m.Size()
}
func (m *PeerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PeerInfo proto.InternalMessageInfo

func (m *PeerInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PeerInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type NetworkInfo struct {
	ID                   string      `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	PeerCount            int32       `protobuf:"varint,2,opt,name=peerCount,proto3" json:"peerCount,omitempty"`
	PeerInfo             []*PeerInfo `protobuf:"bytes,3,rep,name=peerInfo" json:"peerInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NetworkInfo) Reset()         { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()    {}
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{9}
}
func (m *NetworkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetworkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInfo.Merge(dst, src)
}
func (m *NetworkInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInfo proto.InternalMessageInfo

func (m *NetworkInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *NetworkInfo) GetPeerCount() int32 {
	if m != nil {
		return m.PeerCount
	}
	return 0
}

func (m *NetworkInfo) GetPeerInfo() []*PeerInfo {
	if m != nil {
		return m.PeerInfo
	}
	return nil
}

type NodeInfoRes struct {
	// build time and git hash
	BuildTime            string       `protobuf:"bytes,1,opt,name=buildTime,proto3" json:"buildTime,omitempty"`
	GitHash              string       `protobuf:"bytes,2,opt,name=gitHash,proto3" json:"gitHash,omitempty"`
	Mode                 string       `protobuf:"bytes,3,opt,name=mode,proto3" json:"mode,omitempty"`
	Network              *NetworkInfo `protobuf:"bytes,4,opt,name=network" json:"network,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NodeInfoRes) Reset()         { *m = NodeInfoRes{} }
func (m *NodeInfoRes) String() string { return proto.CompactTextString(m) }
func (*NodeInfoRes) ProtoMessage()    {}
func (*NodeInfoRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{10}
}
func (m *NodeInfoRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfoRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfoRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NodeInfoRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfoRes.Merge(dst, src)
}
func (m *NodeInfoRes) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfoRes) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfoRes.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfoRes proto.InternalMessageInfo

func (m *NodeInfoRes) GetBuildTime() string {
	if m != nil {
		return m.BuildTime
	}
	return ""
}

func (m *NodeInfoRes) GetGitHash() string {
	if m != nil {
		return m.GitHash
	}
	return ""
}

func (m *NodeInfoRes) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *NodeInfoRes) GetNetwork() *NetworkInfo {
	if m != nil {
		return m.Network
	}
	return nil
}

type BlockInfo struct {
	// BlockHead
	Head *pb1.BlockHead `protobuf:"bytes,1,opt,name=head" json:"head,omitempty"`
	// block hash
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// transaction list,works when complete is true
	Txs []*pb.Tx `protobuf:"bytes,3,rep,name=txs" json:"txs,omitempty"`
	// transaction hash list,works when complete is false
	Txhash []string `protobuf:"bytes,4,rep,name=txhash" json:"txhash,omitempty"`
	// transaction receipt list
	Receipts []*pb.TxReceipt `protobuf:"bytes,5,rep,name=receipts" json:"receipts,omitempty"`
	// transaction receiptHash list
	ReceiptHash          []string `protobuf:"bytes,6,rep,name=receiptHash" json:"receiptHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockInfo) Reset()         { *m = BlockInfo{} }
func (m *BlockInfo) String() string { return proto.CompactTextString(m) }
func (*BlockInfo) ProtoMessage()    {}
func (*BlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{11}
}
func (m *BlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockInfo.Merge(dst, src)
}
func (m *BlockInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockInfo proto.InternalMessageInfo

func (m *BlockInfo) GetHead() *pb1.BlockHead {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *BlockInfo) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *BlockInfo) GetTxs() []*pb.Tx {
	if m != nil {
		return m.Txs
	}
	return nil
}

func (m *BlockInfo) GetTxhash() []string {
	if m != nil {
		return m.Txhash
	}
	return nil
}

func (m *BlockInfo) GetReceipts() []*pb.TxReceipt {
	if m != nil {
		return m.Receipts
	}
	return nil
}

func (m *BlockInfo) GetReceiptHash() []string {
	if m != nil {
		return m.ReceiptHash
	}
	return nil
}

type ChainInfoRes struct {
	NetType         string   `protobuf:"bytes,1,opt,name=netType,proto3" json:"netType,omitempty"`
	ProtocolVersion string   `protobuf:"bytes,2,opt,name=protocolVersion,proto3" json:"protocolVersion,omitempty"`
	Height          int64    `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	WitnessList     []string `protobuf:"bytes,4,rep,name=witnessList" json:"witnessList,omitempty"`
	// the longest chain block
	HeadBlock *BlockInfo `protobuf:"bytes,5,opt,name=headBlock" json:"headBlock,omitempty"`
	// the latest confirmed block
	LatestConfirmedBlock *BlockInfo `protobuf:"bytes,6,opt,name=latestConfirmedBlock" json:"latestConfirmedBlock,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ChainInfoRes) Reset()         { *m = ChainInfoRes{} }
func (m *ChainInfoRes) String() string { return proto.CompactTextString(m) }
func (*ChainInfoRes) ProtoMessage()    {}
func (*ChainInfoRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{12}
}
func (m *ChainInfoRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainInfoRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainInfoRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChainInfoRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainInfoRes.Merge(dst, src)
}
func (m *ChainInfoRes) XXX_Size() int {
	return m.Size()
}
func (m *ChainInfoRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainInfoRes.DiscardUnknown(m)
}

var xxx_messageInfo_ChainInfoRes proto.InternalMessageInfo

func (m *ChainInfoRes) GetNetType() string {
	if m != nil {
		return m.NetType
	}
	return ""
}

func (m *ChainInfoRes) GetProtocolVersion() string {
	if m != nil {
		return m.ProtocolVersion
	}
	return ""
}

func (m *ChainInfoRes) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ChainInfoRes) GetWitnessList() []string {
	if m != nil {
		return m.WitnessList
	}
	return nil
}

func (m *ChainInfoRes) GetHeadBlock() *BlockInfo {
	if m != nil {
		return m.HeadBlock
	}
	return nil
}

func (m *ChainInfoRes) GetLatestConfirmedBlock() *BlockInfo {
	if m != nil {
		return m.LatestConfirmedBlock
	}
	return nil
}

type GetAccountRes struct {
	// the queried balance
	Balance int64 `protobuf:"varint,1,opt,name=balance,proto3" json:"balance,omitempty"`
	// current gas
	Gas                  string   `protobuf:"bytes,2,opt,name=gas,proto3" json:"gas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAccountRes) Reset()         { *m = GetAccountRes{} }
func (m *GetAccountRes) String() string { return proto.CompactTextString(m) }
func (*GetAccountRes) ProtoMessage()    {}
func (*GetAccountRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{13}
}
func (m *GetAccountRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAccountRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountRes.Merge(dst, src)
}
func (m *GetAccountRes) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountRes) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountRes.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountRes proto.InternalMessageInfo

func (m *GetAccountRes) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *GetAccountRes) GetGas() string {
	if m != nil {
		return m.Gas
	}
	return ""
}

type GetContractStorageRes struct {
	// the value of the corresponding key in the StateDB
	JsonStr              string   `protobuf:"bytes,1,opt,name=jsonStr,proto3" json:"jsonStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContractStorageRes) Reset()         { *m = GetContractStorageRes{} }
func (m *GetContractStorageRes) String() string { return proto.CompactTextString(m) }
func (*GetContractStorageRes) ProtoMessage()    {}
func (*GetContractStorageRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{14}
}
func (m *GetContractStorageRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContractStorageRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContractStorageRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetContractStorageRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContractStorageRes.Merge(dst, src)
}
func (m *GetContractStorageRes) XXX_Size() int {
	return m.Size()
}
func (m *GetContractStorageRes) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContractStorageRes.DiscardUnknown(m)
}

var xxx_messageInfo_GetContractStorageRes proto.InternalMessageInfo

func (m *GetContractStorageRes) GetJsonStr() string {
	if m != nil {
		return m.JsonStr
	}
	return ""
}

type GetContractRes struct {
	// contract id
	Value                *contract.Contract `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetContractRes) Reset()         { *m = GetContractRes{} }
func (m *GetContractRes) String() string { return proto.CompactTextString(m) }
func (*GetContractRes) ProtoMessage()    {}
func (*GetContractRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{15}
}
func (m *GetContractRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContractRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContractRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetContractRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContractRes.Merge(dst, src)
}
func (m *GetContractRes) XXX_Size() int {
	return m.Size()
}
func (m *GetContractRes) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContractRes.DiscardUnknown(m)
}

var xxx_messageInfo_GetContractRes proto.InternalMessageInfo

func (m *GetContractRes) GetValue() *contract.Contract {
	if m != nil {
		return m.Value
	}
	return nil
}

type SendTxRes struct {
	// the hash of the received transaction
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendTxRes) Reset()         { *m = SendTxRes{} }
func (m *SendTxRes) String() string { return proto.CompactTextString(m) }
func (*SendTxRes) ProtoMessage()    {}
func (*SendTxRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{16}
}
func (m *SendTxRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTxRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTxRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SendTxRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTxRes.Merge(dst, src)
}
func (m *SendTxRes) XXX_Size() int {
	return m.Size()
}
func (m *SendTxRes) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTxRes.DiscardUnknown(m)
}

var xxx_messageInfo_SendTxRes proto.InternalMessageInfo

func (m *SendTxRes) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type ExecTxRes struct {
	TxReceipt            *pb.TxReceipt `protobuf:"bytes,1,opt,name=txReceipt" json:"txReceipt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ExecTxRes) Reset()         { *m = ExecTxRes{} }
func (m *ExecTxRes) String() string { return proto.CompactTextString(m) }
func (*ExecTxRes) ProtoMessage()    {}
func (*ExecTxRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{17}
}
func (m *ExecTxRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecTxRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecTxRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ExecTxRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecTxRes.Merge(dst, src)
}
func (m *ExecTxRes) XXX_Size() int {
	return m.Size()
}
func (m *ExecTxRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecTxRes.DiscardUnknown(m)
}

var xxx_messageInfo_ExecTxRes proto.InternalMessageInfo

func (m *ExecTxRes) GetTxReceipt() *pb.TxReceipt {
	if m != nil {
		return m.TxReceipt
	}
	return nil
}

type TxRes struct {
	// the queried transaction
	Tx *pb.Tx `protobuf:"bytes,1,opt,name=tx" json:"tx,omitempty"`
	// transaction hash
	Hash                 string   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRes) Reset()         { *m = TxRes{} }
func (m *TxRes) String() string { return proto.CompactTextString(m) }
func (*TxRes) ProtoMessage()    {}
func (*TxRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{18}
}
func (m *TxRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRes.Merge(dst, src)
}
func (m *TxRes) XXX_Size() int {
	return m.Size()
}
func (m *TxRes) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRes.DiscardUnknown(m)
}

var xxx_messageInfo_TxRes proto.InternalMessageInfo

func (m *TxRes) GetTx() *pb.Tx {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *TxRes) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type TxReceiptRes struct {
	// transaction receipt
	TxReceipt            *pb.TxReceipt `protobuf:"bytes,1,opt,name=txReceipt" json:"txReceipt,omitempty"`
	Hash                 string        `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TxReceiptRes) Reset()         { *m = TxReceiptRes{} }
func (m *TxReceiptRes) String() string { return proto.CompactTextString(m) }
func (*TxReceiptRes) ProtoMessage()    {}
func (*TxReceiptRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{19}
}
func (m *TxReceiptRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxReceiptRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxReceiptRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxReceiptRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxReceiptRes.Merge(dst, src)
}
func (m *TxReceiptRes) XXX_Size() int {
	return m.Size()
}
func (m *TxReceiptRes) XXX_DiscardUnknown() {
	xxx_messageInfo_TxReceiptRes.DiscardUnknown(m)
}

var xxx_messageInfo_TxReceiptRes proto.InternalMessageInfo

func (m *TxReceiptRes) GetTxReceipt() *pb.TxReceipt {
	if m != nil {
		return m.TxReceipt
	}
	return nil
}

func (m *TxReceiptRes) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type SubscribeRes struct {
	// event
	Ev                   *event.Event `protobuf:"bytes,1,opt,name=ev" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SubscribeRes) Reset()         { *m = SubscribeRes{} }
func (m *SubscribeRes) String() string { return proto.CompactTextString(m) }
func (*SubscribeRes) ProtoMessage()    {}
func (*SubscribeRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_apis_b0c6f5cdd4c039d8, []int{20}
}
func (m *SubscribeRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SubscribeRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRes.Merge(dst, src)
}
func (m *SubscribeRes) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRes) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRes.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRes proto.InternalMessageInfo

func (m *SubscribeRes) GetEv() *event.Event {
	if m != nil {
		return m.Ev
	}
	return nil
}

func init() {
	proto.RegisterType((*HashReq)(nil), "rpc.HashReq")
	proto.RegisterType((*BlockByHashReq)(nil), "rpc.BlockByHashReq")
	proto.RegisterType((*BlockByNumReq)(nil), "rpc.BlockByNumReq")
	proto.RegisterType((*GetAccountReq)(nil), "rpc.GetAccountReq")
	proto.RegisterType((*GetContractStorageReq)(nil), "rpc.GetContractStorageReq")
	proto.RegisterType((*GetContractReq)(nil), "rpc.GetContractReq")
	proto.RegisterType((*TxReq)(nil), "rpc.TxReq")
	proto.RegisterType((*SubscribeReq)(nil), "rpc.SubscribeReq")
	proto.RegisterType((*PeerInfo)(nil), "rpc.PeerInfo")
	proto.RegisterType((*NetworkInfo)(nil), "rpc.NetworkInfo")
	proto.RegisterType((*NodeInfoRes)(nil), "rpc.NodeInfoRes")
	proto.RegisterType((*BlockInfo)(nil), "rpc.BlockInfo")
	proto.RegisterType((*ChainInfoRes)(nil), "rpc.ChainInfoRes")
	proto.RegisterType((*GetAccountRes)(nil), "rpc.GetAccountRes")
	proto.RegisterType((*GetContractStorageRes)(nil), "rpc.GetContractStorageRes")
	proto.RegisterType((*GetContractRes)(nil), "rpc.GetContractRes")
	proto.RegisterType((*SendTxRes)(nil), "rpc.SendTxRes")
	proto.RegisterType((*ExecTxRes)(nil), "rpc.ExecTxRes")
	proto.RegisterType((*TxRes)(nil), "rpc.txRes")
	proto.RegisterType((*TxReceiptRes)(nil), "rpc.txReceiptRes")
	proto.RegisterType((*SubscribeRes)(nil), "rpc.SubscribeRes")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApisClient is the client API for Apis service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApisClient interface {
	// get the version info
	GetNodeInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NodeInfoRes, error)
	// get the chain info
	GetChainInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ChainInfoRes, error)
	// get the tx by hash
	GetTxByHash(ctx context.Context, in *HashReq, opts ...grpc.CallOption) (*TxRes, error)
	// get receipt by hash
	GetTxReceiptByHash(ctx context.Context, in *HashReq, opts ...grpc.CallOption) (*TxReceiptRes, error)
	// get receipt by txhash
	GetTxReceiptByTxHash(ctx context.Context, in *HashReq, opts ...grpc.CallOption) (*TxReceiptRes, error)
	// get the block by hash
	GetBlockByHash(ctx context.Context, in *BlockByHashReq, opts ...grpc.CallOption) (*BlockInfo, error)
	// get the block by number
	GetBlockByNum(ctx context.Context, in *BlockByNumReq, opts ...grpc.CallOption) (*BlockInfo, error)
	// get the balance of some account by account ID
	GetAccountInfo(ctx context.Context, in *GetAccountReq, opts ...grpc.CallOption) (*GetAccountRes, error)
	// get the value of the corresponding key in stateDB
	GetContractStorage(ctx context.Context, in *GetContractStorageReq, opts ...grpc.CallOption) (*GetContractStorageRes, error)
	// get contract by cid
	GetContract(ctx context.Context, in *GetContractReq, opts ...grpc.CallOption) (*GetContractRes, error)
	// receive encoded tx
	SendTx(ctx context.Context, in *TxReq, opts ...grpc.CallOption) (*SendTxRes, error)
	// not supported yet
	ExecTx(ctx context.Context, in *TxReq, opts ...grpc.CallOption) (*ExecTxRes, error)
	// subscribe an event
	Subscribe(ctx context.Context, in *SubscribeReq, opts ...grpc.CallOption) (Apis_SubscribeClient, error)
}

type apisClient struct {
	cc *grpc.ClientConn
}

func NewApisClient(cc *grpc.ClientConn) ApisClient {
	return &apisClient{cc}
}

func (c *apisClient) GetNodeInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NodeInfoRes, error) {
	out := new(NodeInfoRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetChainInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ChainInfoRes, error) {
	out := new(ChainInfoRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetChainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetTxByHash(ctx context.Context, in *HashReq, opts ...grpc.CallOption) (*TxRes, error) {
	out := new(TxRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetTxByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetTxReceiptByHash(ctx context.Context, in *HashReq, opts ...grpc.CallOption) (*TxReceiptRes, error) {
	out := new(TxReceiptRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetTxReceiptByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetTxReceiptByTxHash(ctx context.Context, in *HashReq, opts ...grpc.CallOption) (*TxReceiptRes, error) {
	out := new(TxReceiptRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetTxReceiptByTxHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetBlockByHash(ctx context.Context, in *BlockByHashReq, opts ...grpc.CallOption) (*BlockInfo, error) {
	out := new(BlockInfo)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetBlockByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetBlockByNum(ctx context.Context, in *BlockByNumReq, opts ...grpc.CallOption) (*BlockInfo, error) {
	out := new(BlockInfo)
	err := c.cc.Invoke(ctx, "/rpc.Apis/getBlockByNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetAccountInfo(ctx context.Context, in *GetAccountReq, opts ...grpc.CallOption) (*GetAccountRes, error) {
	out := new(GetAccountRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetAccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetContractStorage(ctx context.Context, in *GetContractStorageReq, opts ...grpc.CallOption) (*GetContractStorageRes, error) {
	out := new(GetContractStorageRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetContractStorage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) GetContract(ctx context.Context, in *GetContractReq, opts ...grpc.CallOption) (*GetContractRes, error) {
	out := new(GetContractRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/GetContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) SendTx(ctx context.Context, in *TxReq, opts ...grpc.CallOption) (*SendTxRes, error) {
	out := new(SendTxRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/SendTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) ExecTx(ctx context.Context, in *TxReq, opts ...grpc.CallOption) (*ExecTxRes, error) {
	out := new(ExecTxRes)
	err := c.cc.Invoke(ctx, "/rpc.Apis/ExecTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apisClient) Subscribe(ctx context.Context, in *SubscribeReq, opts ...grpc.CallOption) (Apis_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Apis_serviceDesc.Streams[0], "/rpc.Apis/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &apisSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Apis_SubscribeClient interface {
	Recv() (*SubscribeRes, error)
	grpc.ClientStream
}

type apisSubscribeClient struct {
	grpc.ClientStream
}

func (x *apisSubscribeClient) Recv() (*SubscribeRes, error) {
	m := new(SubscribeRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ApisServer is the server API for Apis service.
type ApisServer interface {
	// get the version info
	GetNodeInfo(context.Context, *empty.Empty) (*NodeInfoRes, error)
	// get the chain info
	GetChainInfo(context.Context, *empty.Empty) (*ChainInfoRes, error)
	// get the tx by hash
	GetTxByHash(context.Context, *HashReq) (*TxRes, error)
	// get receipt by hash
	GetTxReceiptByHash(context.Context, *HashReq) (*TxReceiptRes, error)
	// get receipt by txhash
	GetTxReceiptByTxHash(context.Context, *HashReq) (*TxReceiptRes, error)
	// get the block by hash
	GetBlockByHash(context.Context, *BlockByHashReq) (*BlockInfo, error)
	// get the block by number
	GetBlockByNum(context.Context, *BlockByNumReq) (*BlockInfo, error)
	// get the balance of some account by account ID
	GetAccountInfo(context.Context, *GetAccountReq) (*GetAccountRes, error)
	// get the value of the corresponding key in stateDB
	GetContractStorage(context.Context, *GetContractStorageReq) (*GetContractStorageRes, error)
	// get contract by cid
	GetContract(context.Context, *GetContractReq) (*GetContractRes, error)
	// receive encoded tx
	SendTx(context.Context, *TxReq) (*SendTxRes, error)
	// not supported yet
	ExecTx(context.Context, *TxReq) (*ExecTxRes, error)
	// subscribe an event
	Subscribe(*SubscribeReq, Apis_SubscribeServer) error
}

func RegisterApisServer(s *grpc.Server, srv ApisServer) {
	s.RegisterService(&_Apis_serviceDesc, srv)
}

func _Apis_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetNodeInfo(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetChainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetChainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetChainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetChainInfo(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetTxByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetTxByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetTxByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetTxByHash(ctx, req.(*HashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetTxReceiptByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetTxReceiptByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetTxReceiptByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetTxReceiptByHash(ctx, req.(*HashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetTxReceiptByTxHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetTxReceiptByTxHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetTxReceiptByTxHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetTxReceiptByTxHash(ctx, req.(*HashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockByHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetBlockByHash(ctx, req.(*BlockByHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetBlockByNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockByNumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetBlockByNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetBlockByNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetBlockByNum(ctx, req.(*BlockByNumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetAccountInfo(ctx, req.(*GetAccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetContractStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractStorageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetContractStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetContractStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetContractStorage(ctx, req.(*GetContractStorageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_GetContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).GetContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/GetContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).GetContract(ctx, req.(*GetContractReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_SendTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).SendTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/SendTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).SendTx(ctx, req.(*TxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_ExecTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApisServer).ExecTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Apis/ExecTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApisServer).ExecTx(ctx, req.(*TxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apis_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ApisServer).Subscribe(m, &apisSubscribeServer{stream})
}

type Apis_SubscribeServer interface {
	Send(*SubscribeRes) error
	grpc.ServerStream
}

type apisSubscribeServer struct {
	grpc.ServerStream
}

func (x *apisSubscribeServer) Send(m *SubscribeRes) error {
	return x.ServerStream.SendMsg(m)
}

var _Apis_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Apis",
	HandlerType: (*ApisServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodeInfo",
			Handler:    _Apis_GetNodeInfo_Handler,
		},
		{
			MethodName: "GetChainInfo",
			Handler:    _Apis_GetChainInfo_Handler,
		},
		{
			MethodName: "GetTxByHash",
			Handler:    _Apis_GetTxByHash_Handler,
		},
		{
			MethodName: "GetTxReceiptByHash",
			Handler:    _Apis_GetTxReceiptByHash_Handler,
		},
		{
			MethodName: "GetTxReceiptByTxHash",
			Handler:    _Apis_GetTxReceiptByTxHash_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _Apis_GetBlockByHash_Handler,
		},
		{
			MethodName: "getBlockByNum",
			Handler:    _Apis_GetBlockByNum_Handler,
		},
		{
			MethodName: "GetAccountInfo",
			Handler:    _Apis_GetAccountInfo_Handler,
		},
		{
			MethodName: "GetContractStorage",
			Handler:    _Apis_GetContractStorage_Handler,
		},
		{
			MethodName: "GetContract",
			Handler:    _Apis_GetContract_Handler,
		},
		{
			MethodName: "SendTx",
			Handler:    _Apis_SendTx_Handler,
		},
		{
			MethodName: "ExecTx",
			Handler:    _Apis_ExecTx_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _Apis_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc/apis.proto",
}

func (m *HashReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockByHashReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockByHashReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.Complete {
		dAtA[i] = 0x10
		i++
		if m.Complete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockByNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockByNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Num))
	}
	if m.Complete {
		dAtA[i] = 0x10
		i++
		if m.Complete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAccountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.UseLongestChain {
		dAtA[i] = 0x10
		i++
		if m.UseLongestChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContractStorageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContractStorageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContractID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.ContractID)))
		i += copy(dAtA[i:], m.ContractID)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Field) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Field)))
		i += copy(dAtA[i:], m.Field)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContractReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContractReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContractID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.ContractID)))
		i += copy(dAtA[i:], m.ContractID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Tx.Size()))
		n1, err := m.Tx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubscribeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		dAtA3 := make([]byte, len(m.Topics)*10)
		var j2 int
		for _, num := range m.Topics {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PeerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.PeerCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.PeerCount))
	}
	if len(m.PeerInfo) > 0 {
		for _, msg := range m.PeerInfo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeInfoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfoRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuildTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.BuildTime)))
		i += copy(dAtA[i:], m.BuildTime)
	}
	if len(m.GitHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.GitHash)))
		i += copy(dAtA[i:], m.GitHash)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if m.Network != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Network.Size()))
		n4, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Head != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Head.Size()))
		n5, err := m.Head.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Txs) > 0 {
		for _, msg := range m.Txs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Txhash) > 0 {
		for _, s := range m.Txhash {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Receipts) > 0 {
		for _, msg := range m.Receipts {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintApis(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReceiptHash) > 0 {
		for _, s := range m.ReceiptHash {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainInfoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainInfoRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NetType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.NetType)))
		i += copy(dAtA[i:], m.NetType)
	}
	if len(m.ProtocolVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.ProtocolVersion)))
		i += copy(dAtA[i:], m.ProtocolVersion)
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Height))
	}
	if len(m.WitnessList) > 0 {
		for _, s := range m.WitnessList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HeadBlock != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.HeadBlock.Size()))
		n6, err := m.HeadBlock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LatestConfirmedBlock != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.LatestConfirmedBlock.Size()))
		n7, err := m.LatestConfirmedBlock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAccountRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Balance != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Balance))
	}
	if len(m.Gas) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Gas)))
		i += copy(dAtA[i:], m.Gas)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContractStorageRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContractStorageRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JsonStr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.JsonStr)))
		i += copy(dAtA[i:], m.JsonStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContractRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContractRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Value.Size()))
		n8, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendTxRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTxRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecTxRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecTxRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxReceipt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.TxReceipt.Size()))
		n9, err := m.TxReceipt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Tx.Size()))
		n10, err := m.Tx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxReceiptRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxReceiptRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxReceipt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.TxReceipt.Size()))
		n11, err := m.TxReceipt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApis(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubscribeRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ev != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApis(dAtA, i, uint64(m.Ev.Size()))
		n12, err := m.Ev.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApis(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HashReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockByHashReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.Complete {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockByNumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovApis(uint64(m.Num))
	}
	if m.Complete {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAccountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.UseLongestChain {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContractStorageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractID)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContractReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractID)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Topics) > 0 {
		l = 0
		for _, e := range m.Topics {
			l += sovApis(uint64(e))
		}
		n += 1 + sovApis(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.PeerCount != 0 {
		n += 1 + sovApis(uint64(m.PeerCount))
	}
	if len(m.PeerInfo) > 0 {
		for _, e := range m.PeerInfo {
			l = e.Size()
			n += 1 + l + sovApis(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfoRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildTime)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.GitHash)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovApis(uint64(l))
		}
	}
	if len(m.Txhash) > 0 {
		for _, s := range m.Txhash {
			l = len(s)
			n += 1 + l + sovApis(uint64(l))
		}
	}
	if len(m.Receipts) > 0 {
		for _, e := range m.Receipts {
			l = e.Size()
			n += 1 + l + sovApis(uint64(l))
		}
	}
	if len(m.ReceiptHash) > 0 {
		for _, s := range m.ReceiptHash {
			l = len(s)
			n += 1 + l + sovApis(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainInfoRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetType)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.ProtocolVersion)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovApis(uint64(m.Height))
	}
	if len(m.WitnessList) > 0 {
		for _, s := range m.WitnessList {
			l = len(s)
			n += 1 + l + sovApis(uint64(l))
		}
	}
	if m.HeadBlock != nil {
		l = m.HeadBlock.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	if m.LatestConfirmedBlock != nil {
		l = m.LatestConfirmedBlock.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAccountRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Balance != 0 {
		n += 1 + sovApis(uint64(m.Balance))
	}
	l = len(m.Gas)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContractStorageRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JsonStr)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContractRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendTxRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecTxRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxReceipt != nil {
		l = m.TxReceipt.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxReceiptRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxReceipt != nil {
		l = m.TxReceipt.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ev != nil {
		l = m.Ev.Size()
		n += 1 + l + sovApis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApis(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApis(x uint64) (n int) {
	return sovApis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HashReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockByHashReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockByHashReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockByHashReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Complete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockByNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockByNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockByNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Complete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLongestChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseLongestChain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContractStorageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContractStorageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContractStorageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContractReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContractReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContractReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &pb.Tx{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v event.Event_Topic
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (event.Event_Topic(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Topics = append(m.Topics, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApis
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Topics) == 0 {
					m.Topics = make([]event.Event_Topic, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v event.Event_Topic
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (event.Event_Topic(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Topics = append(m.Topics, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerCount", wireType)
			}
			m.PeerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerInfo = append(m.PeerInfo, &PeerInfo{})
			if err := m.PeerInfo[len(m.PeerInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &NetworkInfo{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &pb1.BlockHead{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, &pb.Tx{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txhash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txhash = append(m.Txhash, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receipts = append(m.Receipts, &pb.TxReceipt{})
			if err := m.Receipts[len(m.Receipts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiptHash = append(m.ReceiptHash, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainInfoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainInfoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainInfoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WitnessList = append(m.WitnessList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeadBlock == nil {
				m.HeadBlock = &BlockInfo{}
			}
			if err := m.HeadBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestConfirmedBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestConfirmedBlock == nil {
				m.LatestConfirmedBlock = &BlockInfo{}
			}
			if err := m.LatestConfirmedBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gas = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContractStorageRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContractStorageRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContractStorageRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsonStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContractRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContractRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContractRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &contract.Contract{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTxRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTxRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTxRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecTxRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecTxRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecTxRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxReceipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxReceipt == nil {
				m.TxReceipt = &pb.TxReceipt{}
			}
			if err := m.TxReceipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: txRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: txRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &pb.Tx{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxReceiptRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: txReceiptRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: txReceiptRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxReceipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxReceipt == nil {
				m.TxReceipt = &pb.TxReceipt{}
			}
			if err := m.TxReceipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ev == nil {
				m.Ev = &event.Event{}
			}
			if err := m.Ev.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApis
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApis
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApis(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApis = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApis   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rpc/apis.proto", fileDescriptor_apis_b0c6f5cdd4c039d8) }

var fileDescriptor_apis_b0c6f5cdd4c039d8 = []byte{
	// 1270 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdd, 0x6e, 0x1b, 0xc5,
	0x17, 0xff, 0xaf, 0x1d, 0x27, 0xf6, 0x89, 0xe3, 0xb6, 0xd3, 0xb4, 0xf2, 0x7f, 0x1b, 0xd2, 0x64,
	0x40, 0xc5, 0x0d, 0xed, 0x6e, 0x09, 0x20, 0x90, 0x51, 0x25, 0x9a, 0xa6, 0x6a, 0x83, 0x4a, 0x54,
	0x36, 0x16, 0x12, 0x08, 0x04, 0xeb, 0xf5, 0xd8, 0x5e, 0x62, 0xef, 0x2c, 0x3b, 0xe3, 0x74, 0x23,
	0xe3, 0x1b, 0x24, 0x9e, 0x80, 0x1b, 0x1e, 0x09, 0x71, 0x85, 0xc4, 0x0b, 0xa0, 0xc2, 0x1d, 0xef,
	0x80, 0xd0, 0x9c, 0x9d, 0x5d, 0xaf, 0x3f, 0x5a, 0x85, 0x9b, 0xd5, 0xcc, 0xd9, 0xf3, 0xfb, 0x9d,
	0x33, 0xe7, 0x6b, 0x06, 0x6a, 0x51, 0xe8, 0xd9, 0x6e, 0xe8, 0x0b, 0x2b, 0x8c, 0xb8, 0xe4, 0xa4,
	0x18, 0x85, 0x9e, 0xf9, 0x6e, 0xcf, 0x97, 0xfd, 0x51, 0xdb, 0xf2, 0xf8, 0xd0, 0xf6, 0xb9, 0x90,
	0x77, 0x79, 0xb7, 0xeb, 0x7b, 0xbe, 0x3b, 0xb0, 0x7b, 0xfc, 0xae, 0x12, 0xd8, 0x1e, 0x8f, 0x98,
	0x2d, 0x63, 0x3b, 0x6c, 0xdb, 0x32, 0x4e, 0xa0, 0xe6, 0xfd, 0x8b, 0xa1, 0x3c, 0x1e, 0xc8, 0xc8,
	0xf5, 0x64, 0xb6, 0xd0, 0xf0, 0xe6, 0xc5, 0xe0, 0xed, 0x01, 0xf7, 0x4e, 0x95, 0x5d, 0x5c, 0x68,
	0xec, 0xfb, 0x17, 0xc3, 0xb2, 0x33, 0x16, 0xc8, 0xe4, 0xab, 0x81, 0x5b, 0x3d, 0xce, 0x7b, 0x03,
	0xa6, 0x22, 0x60, 0xbb, 0x41, 0xc0, 0xa5, 0x2b, 0x7d, 0x1e, 0xe8, 0x60, 0x98, 0x37, 0xf4, 0x5f,
	0xdc, 0xb5, 0x47, 0x5d, 0xfb, 0xd1, 0x30, 0x94, 0xe7, 0xc9, 0x4f, 0xfa, 0x1a, 0xac, 0x3d, 0x71,
	0x45, 0xdf, 0x61, 0xdf, 0x11, 0x02, 0x2b, 0x7d, 0x57, 0xf4, 0xeb, 0xc6, 0x8e, 0xd1, 0xa8, 0x38,
	0xb8, 0xa6, 0x1f, 0x41, 0xed, 0x40, 0x79, 0x78, 0x70, 0xfe, 0x0a, 0x2d, 0x62, 0x42, 0xd9, 0xe3,
	0xc3, 0x70, 0xc0, 0x24, 0xab, 0x17, 0x76, 0x8c, 0x46, 0xd9, 0xc9, 0xf6, 0xf4, 0x3e, 0x6c, 0x68,
	0x86, 0xe3, 0xd1, 0x50, 0x11, 0x5c, 0x86, 0x62, 0x30, 0x1a, 0x22, 0xbe, 0xe8, 0xa8, 0xe5, 0x2b,
	0xe1, 0x47, 0xb0, 0xf1, 0x98, 0xc9, 0x07, 0x9e, 0xc7, 0x47, 0x81, 0x54, 0xf0, 0x1a, 0x14, 0x8e,
	0x0e, 0xb5, 0xf5, 0xc2, 0xd1, 0x21, 0x69, 0xc0, 0xa5, 0x91, 0x60, 0x4f, 0x79, 0xd0, 0x63, 0x42,
	0x3e, 0xec, 0xbb, 0x7e, 0xa0, 0x39, 0xe6, 0xc5, 0xf4, 0x6b, 0xb8, 0xf6, 0x98, 0xc9, 0x87, 0x3a,
	0x5f, 0x27, 0x92, 0x47, 0x6e, 0x8f, 0x29, 0xca, 0x6d, 0x80, 0x34, 0x8b, 0x19, 0x75, 0x4e, 0xa2,
	0x3c, 0x3e, 0x65, 0xe7, 0x48, 0x5b, 0x71, 0xd4, 0x92, 0x6c, 0x42, 0xa9, 0xeb, 0xb3, 0x41, 0xa7,
	0x5e, 0x44, 0x59, 0xb2, 0xa1, 0xf7, 0xa0, 0x96, 0x33, 0x70, 0x01, 0x66, 0xba, 0x0b, 0xa5, 0x56,
	0xac, 0x14, 0xeb, 0x50, 0x90, 0x31, 0x2a, 0xac, 0xef, 0x97, 0x2d, 0x19, 0x87, 0x6d, 0xab, 0x15,
	0x3b, 0x05, 0x19, 0xd3, 0x26, 0x54, 0x4f, 0x46, 0x6d, 0xe1, 0x45, 0x7e, 0x1b, 0x9d, 0xdd, 0x83,
	0x55, 0xc9, 0x43, 0xdf, 0x13, 0x75, 0x63, 0xa7, 0xd8, 0xa8, 0xed, 0x13, 0x2b, 0xa9, 0x84, 0x47,
	0xf8, 0x6d, 0xa9, 0x5f, 0x8e, 0xd6, 0xa0, 0x16, 0x94, 0x9f, 0x31, 0x16, 0x1d, 0x05, 0x5d, 0xbe,
	0x10, 0x37, 0x02, 0x2b, 0x6e, 0xa7, 0x13, 0xe9, 0x53, 0xe1, 0x9a, 0x76, 0x61, 0xfd, 0x98, 0xc9,
	0xe7, 0x3c, 0x3a, 0x5d, 0x0a, 0xd9, 0x82, 0x4a, 0xc8, 0x58, 0xf4, 0x50, 0xa5, 0x02, 0x71, 0x25,
	0x67, 0x2a, 0x20, 0xb7, 0xa1, 0x1c, 0x6a, 0x63, 0xf5, 0xe2, 0x4e, 0xb1, 0xb1, 0xbe, 0xbf, 0x61,
	0x45, 0xa1, 0x67, 0xa5, 0x1e, 0x38, 0xd9, 0x6f, 0xfa, 0xa3, 0x01, 0xeb, 0xc7, 0xbc, 0xc3, 0x50,
	0xcc, 0x84, 0x22, 0x6e, 0x8f, 0xfc, 0x41, 0xa7, 0xe5, 0x0f, 0x99, 0xb6, 0x37, 0x15, 0x90, 0x3a,
	0xac, 0xf5, 0x7c, 0xa9, 0xea, 0x4f, 0x3b, 0x9b, 0x6e, 0xd5, 0x19, 0x86, 0xbc, 0xc3, 0x74, 0x16,
	0x70, 0x4d, 0xf6, 0x60, 0x2d, 0x48, 0xce, 0x50, 0x5f, 0xc1, 0x70, 0x5e, 0x46, 0x2f, 0x72, 0xe7,
	0x72, 0x52, 0x05, 0xfa, 0xab, 0x01, 0x15, 0x2c, 0x4e, 0x3c, 0xee, 0x2d, 0x58, 0xe9, 0x33, 0xb7,
	0xa3, 0xb3, 0x40, 0x2c, 0x6c, 0xcd, 0xb0, 0x6d, 0xa1, 0xc6, 0x13, 0xe6, 0x76, 0x1c, 0xfc, 0x9f,
	0x75, 0x40, 0x61, 0xa6, 0x03, 0x8a, 0x32, 0x16, 0xfa, 0xdc, 0xd3, 0x04, 0x2a, 0x21, 0xb9, 0x0e,
	0xab, 0x32, 0x46, 0xc4, 0xca, 0x4e, 0xb1, 0x51, 0x71, 0xf4, 0x8e, 0xbc, 0x05, 0xe5, 0x88, 0x79,
	0xcc, 0x0f, 0xa5, 0xa8, 0x97, 0x10, 0x78, 0x29, 0x03, 0x26, 0x72, 0x27, 0x53, 0x20, 0x3b, 0xb0,
	0xae, 0xd7, 0x18, 0x88, 0x55, 0x64, 0xca, 0x8b, 0xe8, 0x3f, 0x06, 0x54, 0xb1, 0xd0, 0xd3, 0xa8,
	0xd6, 0x31, 0x12, 0xad, 0xf3, 0x30, 0x8d, 0x69, 0xba, 0x55, 0x3d, 0x83, 0xdd, 0xef, 0xf1, 0xc1,
	0x67, 0x2c, 0x12, 0x3e, 0x0f, 0xf4, 0x61, 0xe6, 0xc5, 0xca, 0xf7, 0x3e, 0xf3, 0x7b, 0x7d, 0x89,
	0x31, 0x2e, 0x3a, 0x7a, 0xa7, 0xdc, 0x79, 0xee, 0xcb, 0x80, 0x09, 0xf1, 0xd4, 0x17, 0x52, 0x1f,
	0x2c, 0x2f, 0x22, 0x77, 0xa0, 0xa2, 0xa2, 0x85, 0xc1, 0xab, 0x97, 0x30, 0xa4, 0x35, 0xcc, 0x44,
	0x16, 0x70, 0x67, 0xaa, 0x40, 0x0e, 0x60, 0x73, 0xe0, 0x4a, 0xd5, 0xaa, 0x3c, 0xe8, 0xfa, 0xd1,
	0x90, 0x69, 0xe0, 0xea, 0x52, 0xe0, 0x52, 0x5d, 0xfa, 0xe1, 0xec, 0xa8, 0xc0, 0x00, 0xb4, 0xdd,
	0x81, 0x1b, 0x78, 0x4c, 0x4f, 0x9b, 0x74, 0xab, 0x3a, 0xba, 0xe7, 0x8a, 0xb4, 0xa3, 0x7b, 0xae,
	0xa0, 0x6f, 0x2f, 0x1f, 0x0e, 0x48, 0xf2, 0xad, 0xe0, 0xc1, 0x89, 0x8c, 0xd2, 0x28, 0xea, 0x2d,
	0x6d, 0xce, 0xb5, 0xbb, 0x20, 0x0d, 0x28, 0x9d, 0xb9, 0x83, 0x11, 0xcb, 0x4a, 0x28, 0xbb, 0x1c,
	0x32, 0xad, 0x44, 0x81, 0xde, 0x84, 0xca, 0x09, 0x0b, 0x3a, 0x2a, 0xd3, 0x62, 0xe9, 0xe0, 0x6d,
	0x42, 0xe5, 0x51, 0xcc, 0xbc, 0x44, 0xe1, 0x2e, 0x54, 0x64, 0x5a, 0x13, 0x9a, 0x7b, 0xa1, 0x54,
	0xa6, 0x1a, 0xf4, 0x3d, 0x28, 0xc9, 0x38, 0xf1, 0xfd, 0x25, 0x53, 0x65, 0x59, 0x0d, 0xd3, 0x4f,
	0xa1, 0x9a, 0x71, 0xfc, 0x77, 0xab, 0x4b, 0x29, 0xef, 0xcc, 0x0c, 0x2f, 0xd5, 0xe8, 0x05, 0x76,
	0xa6, 0xb9, 0xaa, 0xf9, 0xc1, 0xe5, 0x14, 0xd8, 0xd9, 0xfe, 0xdf, 0x65, 0x58, 0x79, 0x10, 0xfa,
	0x82, 0x7c, 0x02, 0xeb, 0x8f, 0x99, 0x4c, 0x27, 0x04, 0xb9, 0x6e, 0x25, 0x37, 0x98, 0x95, 0xde,
	0x60, 0x16, 0xde, 0x60, 0xa6, 0xee, 0xec, 0xe9, 0x20, 0xa1, 0x9b, 0x3f, 0xfc, 0xfe, 0xd7, 0x4f,
	0x85, 0x1a, 0xa9, 0xda, 0xbd, 0x1c, 0xfe, 0x19, 0x54, 0x55, 0xa2, 0xd2, 0xde, 0x78, 0x29, 0xdf,
	0x15, 0xe4, 0xcb, 0xf7, 0x10, 0xbd, 0x86, 0x84, 0x97, 0xc8, 0x86, 0x22, 0x9c, 0x32, 0x1c, 0xa2,
	0x83, 0xad, 0x38, 0xb9, 0x16, 0x49, 0x15, 0x81, 0xfa, 0x86, 0x34, 0x01, 0x77, 0x98, 0x01, 0x7a,
	0x03, 0xf1, 0xd7, 0xc8, 0x55, 0x85, 0x4f, 0xf5, 0xed, 0xb1, 0x0a, 0xce, 0x84, 0x7c, 0x0e, 0x04,
	0x59, 0x74, 0x04, 0x97, 0x92, 0x5d, 0xc9, 0xc8, 0xd2, 0xbc, 0x50, 0x8a, 0x9c, 0x5b, 0xc4, 0x4c,
	0x38, 0x67, 0xd0, 0x29, 0xf5, 0x57, 0xb0, 0x39, 0x4b, 0xdd, 0x8a, 0x2f, 0x46, 0xfe, 0x06, 0x92,
	0x6f, 0x93, 0xad, 0x39, 0xf2, 0x04, 0x9f, 0xd2, 0x7f, 0x83, 0xa5, 0x9f, 0x7b, 0x19, 0x90, 0xab,
	0xd3, 0x16, 0xcd, 0xde, 0x0a, 0xe6, 0x5c, 0xdf, 0xd2, 0xdb, 0x48, 0xfe, 0x3a, 0xd9, 0x55, 0xe4,
	0x39, 0x5d, 0x4d, 0x6b, 0x8f, 0xd3, 0x6b, 0x7f, 0x42, 0xbe, 0x84, 0x8d, 0xa9, 0xce, 0xf1, 0x68,
	0x48, 0x48, 0xde, 0x40, 0xf2, 0x94, 0x58, 0xe0, 0x7f, 0x13, 0xf9, 0x77, 0xc9, 0x4d, 0x7b, 0x06,
	0x6b, 0x8f, 0x83, 0xd1, 0x70, 0x86, 0xbd, 0x8f, 0xfe, 0xeb, 0x51, 0x81, 0x19, 0x4d, 0xe8, 0x67,
	0x9e, 0x1a, 0xe6, 0xa2, 0x4c, 0x50, 0x0b, 0x4d, 0x34, 0xc8, 0x2d, 0x65, 0x22, 0x47, 0x60, 0x8f,
	0x8f, 0x0e, 0x27, 0xf6, 0x78, 0xee, 0xcd, 0x31, 0x21, 0xdf, 0x63, 0x8e, 0xe7, 0xe6, 0x0a, 0x31,
	0x53, 0xe6, 0xc5, 0xd7, 0x88, 0xf9, 0xf2, 0x7f, 0x73, 0xd6, 0xe7, 0xfe, 0xab, 0xf3, 0xa5, 0x0f,
	0x8b, 0x89, 0x3d, 0x3e, 0x65, 0xe7, 0x13, 0xf2, 0x05, 0xd6, 0x69, 0xaa, 0xa8, 0x93, 0x34, 0xfb,
	0x46, 0x31, 0x97, 0x08, 0x05, 0xdd, 0x45, 0x43, 0x37, 0xc8, 0xff, 0xf3, 0x86, 0x66, 0x2c, 0x90,
	0x0f, 0x60, 0x35, 0x19, 0x61, 0x24, 0x29, 0x78, 0x7c, 0xc8, 0xe8, 0x94, 0x64, 0xb3, 0x8d, 0x12,
	0x24, 0xaa, 0xd2, 0x35, 0x5b, 0xa0, 0xac, 0x69, 0xec, 0x29, 0x64, 0x32, 0xdb, 0x96, 0x20, 0xb3,
	0xa1, 0x97, 0x43, 0x32, 0x94, 0x29, 0xe4, 0xc7, 0x50, 0xc9, 0xe6, 0x09, 0x49, 0xaa, 0x37, 0xff,
	0x38, 0x32, 0x17, 0x44, 0x59, 0x07, 0x53, 0xb0, 0x45, 0x2a, 0x6e, 0x1a, 0x7b, 0xf7, 0x8c, 0x83,
	0xcb, 0xbf, 0xbc, 0xd8, 0x36, 0x7e, 0x7b, 0xb1, 0x6d, 0xfc, 0xf1, 0x62, 0xdb, 0xf8, 0xf9, 0xcf,
	0xed, 0xff, 0xb5, 0x57, 0x71, 0x1e, 0xbc, 0xf3, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd2, 0xcc,
	0x80, 0x0f, 0x4e, 0x0c, 0x00, 0x00,
}
